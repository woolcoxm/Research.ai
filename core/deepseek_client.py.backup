import requests
import json
import logging
from typing import List, Dict, Any, Optional
from config.settings import Config
from core.models import LLMMessage, LLMType

logger = logging.getLogger(__name__)


class DeepSeekClient:
    """Client for interacting with DeepSeek API"""
    
    def __init__(self):
        self.api_key = Config.DEEPSEEK_API_KEY
        self.base_url = Config.DEEPSEEK_BASE_URL
        self.timeout = Config.REQUEST_TIMEOUT
        
        if not self.api_key:
            raise ValueError("DeepSeek API key not configured")
    
    def _make_request(self, endpoint: str, data: Dict[str, Any], retry_count: int = 3) -> Dict[str, Any]:
        """Make API request to DeepSeek with retry logic"""
        url = f"{self.base_url}/{endpoint}"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        last_error = None
        for attempt in range(retry_count):
            try:
                logger.info(f"DeepSeek API request attempt {attempt + 1}/{retry_count}")
                response = requests.post(
                    url,
                    headers=headers,
                    json=data,
                    timeout=self.timeout
                )
                response.raise_for_status()
                return response.json()
            except requests.exceptions.Timeout as e:
                last_error = e
                logger.warning(f"DeepSeek API timeout on attempt {attempt + 1}/{retry_count}: {e}")
                if attempt < retry_count - 1:
                    logger.info(f"Retrying in 5 seconds...")
                    import time
                    time.sleep(5)
            except requests.exceptions.RequestException as e:
                last_error = e
                logger.error(f"DeepSeek API request failed on attempt {attempt + 1}/{retry_count}: {e}")
                # Don't retry on non-timeout errors (like 4xx status codes)
                if attempt < retry_count - 1 and (isinstance(e, requests.exceptions.ConnectionError) or 
                                                   (hasattr(e.response, 'status_code') and e.response.status_code >= 500)):
                    logger.info(f"Retrying in 5 seconds...")
                    import time
                    time.sleep(5)
                else:
                    raise
        
        logger.error(f"DeepSeek API request failed after {retry_count} attempts")
        raise last_error
    
    def generate_response(self, 
                         prompt: str, 
                         context: Optional[str] = None,
                         temperature: float = None,
                         max_tokens: int = None) -> LLMMessage:
        """Generate a response from DeepSeek"""
        
        # Use config defaults if not specified
        if temperature is None:
            temperature = Config.DEEPSEEK_DEFAULT_TEMPERATURE
        if max_tokens is None:
            max_tokens = Config.DEEPSEEK_DEFAULT_MAX_TOKENS
        
        # Build the messages array
        messages = []
        
        if context:
            messages.append({
                "role": "system",
                "content": (
                    f"You are an expert AI researcher, senior software architect, and implementation specialist. Use the following research context to inform your analysis:\n\n{context}\n\n"
                    "When answering, provide COMPREHENSIVE IMPLEMENTATION GUIDANCE:\n"
                    "1) Reference specific search results or key insights provided in context and cite sources in [Source: URL] format.\n"
                    "2) Provide BOTH architecture AND detailed implementation guidance: system design, code examples, configuration files, and setup procedures.\n"
                    "3) Include DETAILED CODE EXAMPLES with complete implementations - not just pseudocode or snippets. Show actual working code.\n"
                    "4) When making recommendations, explain trade-offs, design decisions, WHY certain approaches are chosen, AND HOW to implement them.\n"
                    "5) Include step-by-step implementation procedures, configuration examples, and troubleshooting guidance.\n"
                    "6) Provide PRODUCTION-READY implementation guidance - what to build, why, how to build it, and how to deploy it.\n"
                    "7) Include complete file structures, configuration files, dependency lists, and deployment scripts.\n"
                    "8) Add code comments, error handling examples, and best practices for each implementation.\n"
                    "Provide comprehensive documentation suitable for developers to take a project from start to finish."
                )
            })
        else:
            messages.append({
                "role": "system",
                "content": "You are an expert AI researcher, software architect, and implementation specialist. Provide detailed architectural analysis, design decisions, AND comprehensive implementation guidance with complete code examples, configurations, and step-by-step procedures."
            })
        
        messages.append({
            "role": "user",
            "content": prompt
        })
        
        # Add explicit instruction to cite sources from the context when referencing research
        citation_instruction = "\n\nWhen referencing research or facts, cite the source using the format: [Source: URL]. If multiple sources support a claim, list them."
        if context:
            messages[0]['content'] += citation_instruction

        request_data = {
            "model": Config.DEEPSEEK_MODEL,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens,
            "stream": False
        }
        
        try:
            response_data = self._make_request("chat/completions", request_data)
            
            # Extract the response content
            content = response_data["choices"][0]["message"]["content"]
            # Log prompt and response sizes for debugging
            try:
                prompt_len = len(json.dumps(request_data))
                resp_len = len(content)
                logger.info(f"DeepSeek request size: {prompt_len} bytes, response size: {resp_len} chars, max_tokens: {max_tokens}")
            except Exception:
                pass
            
            # Create LLM message
            message = LLMMessage(
                llm_type=LLMType.DEEPSEEK,
                content=content,
                confidence_score=0.8  # Default confidence
            )
            
            logger.info(f"DeepSeek response generated: {len(content)} characters")
            return message
            
        except Exception as e:
            logger.error(f"Failed to generate DeepSeek response: {e}")
            # Return a fallback message
            return LLMMessage(
                llm_type=LLMType.DEEPSEEK,
                content=f"I encountered an error while processing your request: {str(e)}. Please try again.",
                confidence_score=0.0
            )
    
    def analyze_research_context(self, 
                               user_prompt: str,
                               research_context: str) -> LLMMessage:
        """Analyze research context and provide comprehensive implementation foundation"""
        
        prompt = f"""Hi! I'm DeepSeek. I need to create a comprehensive architectural design document and implementation plan for: {user_prompt}

Research findings:
{research_context}

IMPORTANT: Focus on ARCHITECTURE, DESIGN, and PLANNING - not detailed code implementation. Provide comprehensive documentation that explains WHAT to build and WHY, with minimal code examples.

**COMPREHENSIVE ARCHITECTURAL DESIGN DOCUMENT:**

**1. System Architecture & Design Philosophy**
- Overall system architecture and component breakdown (use diagrams descriptions, NOT code)
- Architectural patterns and design principles
- Technology stack recommendations with justification (explain WHY, not HOW to implement)
- High-level component interaction flows

**2. Data Architecture & API Design**
- Database design philosophy and data modeling approach (schema concepts, not SQL code)
- API design patterns and endpoint structure (REST/GraphQL concepts, not implementations)
- Data flow documentation and state management strategy

**3. Technical Strategy & Technology Choices**
- Frontend architecture approach and framework rationale
- Backend services design and microservices/monolith decision
- Authentication/authorization strategy (concepts, not auth code)
- Integration patterns and third-party service decisions

**4. Infrastructure & Operational Design**
- Deployment architecture and environment strategy
- CI/CD pipeline approach
- Monitoring, logging, and observability strategy
- Disaster recovery and backup considerations

**5. Security, Performance & Scalability Planning**
- Security architecture and threat model
- Performance optimization strategies
- Scalability approach and growth planning
- Error handling philosophy and fault tolerance

**6. Development & Maintenance Plan**
- Project structure and organization principles
- Testing strategy (types of tests, not test code)
- Documentation requirements and standards
- Development workflow and team collaboration approach

Ollama, I want to make sure this architectural plan covers everything needed. What are your thoughts on the design decisions and implementation approach?

FOCUS ON PLANNING DOCUMENTATION - save detailed code for the actual development phase."""
        
        return self.generate_response(prompt, research_context, max_tokens=Config.DEEPSEEK_STAGE5_MAX_TOKENS)
    
    def refine_analysis(self,
                       user_prompt: str,
                       research_context: str,
                       ollama_analysis: str) -> LLMMessage:
        """Refine analysis based on Ollama's input"""
        
        prompt = f"""
        Based on the user's prompt, research context, and Ollama's technical analysis, please refine your recommendations:

        USER PROMPT: {user_prompt}

        RESEARCH CONTEXT: {research_context}

        OLLAMA'S TECHNICAL ANALYSIS: {ollama_analysis}

        Please:
        1. Address any technical concerns raised by Ollama
        2. Update your recommendations based on implementation feasibility
        3. Identify any remaining knowledge gaps that need research
        4. Propose a refined architecture and technology stack

        Focus on building consensus and addressing technical constraints.
        """
        
        return self.generate_response(prompt, research_context, max_tokens=Config.DEEPSEEK_STAGE2_MAX_TOKENS)
    
    def continue_discussion(self, user_prompt: str, research_context: str, ollama_response: str) -> LLMMessage:
        """Continue the discussion based on Ollama's latest points"""
        logger.info("DeepSeek continuing discussion")
        
        # Truncate long responses for context
        if len(ollama_response) > 1000:
            ollama_response = ollama_response[:1000] + "... [truncated for discussion]"
        
        prompt = f"""You are DeepSeek having a conversation with Ollama about: {user_prompt}

Ollama just said:
{ollama_response}

Continue this technical discussion by exploring ONE of these design areas in depth:

**Architecture & Design Patterns:**
- System architecture (microservices vs monolith, layers, separation of concerns)
- Design patterns (MVC, Repository, Factory, Observer, etc.)
- Component interactions and dependencies

**Data & Security:**
- Database design (schema, relationships, indexing, migrations)
- Data flow and state management
- Security architecture (authentication, authorization, data protection)
- Input validation and sanitization strategies

**Performance & Scalability:**
- Performance optimization techniques
- Caching strategies (Redis, CDN, application-level)
- Load balancing and horizontal scaling
- Database optimization and query performance

**Development & Operations:**
- Testing strategy (unit, integration, E2E testing)
- CI/CD pipeline design
- Monitoring, logging, and error handling
- Development workflow and tooling

Pick ONE area that needs more discussion based on Ollama's response. Be specific and technical, but keep it conversational (3-4 paragraphs).

Research context: {research_context[:500]}...
"""
        
        return self.generate_response(prompt, research_context, max_tokens=Config.DEEPSEEK_STAGE5_MAX_TOKENS)
    
    # ==================== NEW: OPTIMIZED DOCUMENT WORKFLOW ====================
    
    def create_document_outline(self, 
                               doc_number: int,
                               doc_type: str,
                               user_prompt: str,
                               research_context: str,
                               conversation_summary: str) -> LLMMessage:
        """Create COMPREHENSIVE outline for PRODUCTION-READY documentation (8K detailed outline)"""
        
        # Build a clean prompt without embedded code to avoid Python syntax issues
        prompt = f"""Create a MASSIVELY DETAILED OUTLINE for Document #{doc_number}: {doc_type}

PROJECT: {user_prompt}

RESEARCH CONTEXT (100+ sources, 128K tokens analyzed):
{research_context[:15000]}

TECHNICAL DISCUSSION:
{conversation_summary[:8000]}


YOUR MISSION: Create a COMPREHENSIVE, PRODUCTION-LEVEL outline that will guide another LLM to write a 20,000-30,000+ word, ENTERPRISE-GRADE implementation guide covering the COMPLETE SOFTWARE DEVELOPMENT LIFECYCLE.

OUTLINE STRUCTURE (Use ALL 8,000 tokens):

# {doc_type}

## DOCUMENT OVERVIEW
**Scope**: Complete production system development from requirements to operations
**Target Length**: 20,000-30,000+ words
**Target Code**: 3,000-5,000+ lines
**Configuration Files**: 30-50+ complete files
**Development Timeline**: 6-8 weeks with detailed breakdown

## PHASE 1: REQUIREMENTS & PLANNING (Week 1)
**Target**: 2,000-3,000 words | Code: 0 lines | Duration: Week 1

### 1.1 Requirements Gathering & Documentation
**Key Points to Cover** (500-800 words):
- 30-50 functional requirements with detailed acceptance criteria
- 20-30 non-functional requirements (performance, security, scalability)
- 20-30 user stories in "As a [role], I want [feature], so that [benefit]" format
- 10-15 use case diagrams (textual/Mermaid descriptions)
- Complete business rules documentation
- Stakeholder analysis and communication plan

**Deliverables to Include**:
- Complete requirements specification document template
- User story mapping examples
- Acceptance criteria checklist
- Requirements traceability matrix

**Research Citations from Context**:
[Pull 5-10 specific facts from research about requirements gathering best practices]

### 1.2 System Architecture Design
**Key Points to Cover** (800-1,200 words):
- High-level architecture diagrams (textual/ASCII/Mermaid)
- Component breakdown (15-30 components with responsibilities)
- Data flow diagrams with complete request/response cycles
- Integration architecture (external APIs, services, dependencies)
- Scalability design (load balancing, caching, database sharding)
- Security architecture (authentication, authorization, encryption)
- Technology stack decisions with detailed justifications

**Deliverables to Include**:
- Architecture Decision Records (ADRs) template with 5-10 examples
- Complete technology comparison matrix
- System context diagrams
- Component interaction diagrams

**Code Examples Needed**: None (planning phase)

### 1.3 Project Structure & File Organization
**Key Points to Cover** (400-600 words):
- Complete folder structure (show 100+ files and folders)
- Frontend structure (20-30 component files, 20-30 pages)
- Backend structure (15-20 services, 15-20 controllers, 15-30 models)
- Test structure (unit, integration, e2e folders)
- Configuration folder structure
- Documentation folder structure

**Deliverables to Include**:
```
Complete ASCII tree structure showing:
/project-root
  /docs (5-10 files)
  /frontend
    /src
      /components (list 20-30 components)
      /pages (list 20-30 pages)
      /services (list 10-15 services)
      ... (complete structure)
  /backend
    /src
      /controllers (list 15-20 controllers)
      /services (list 15-20 services)
      /models (list 15-30 models)
      ... (complete structure)
  /tests (complete test structure)
  /infrastructure (Docker, K8s, Terraform)
  /scripts (build, deploy, migrate)
```

## PHASE 2: ENVIRONMENT SETUP & INITIALIZATION (Week 1, Days 1-5)
**Target**: 3,000-4,000 words | Code: 500-1,000 lines | Duration: 5 days

### 2.1 Day 1: Development Machine Setup
**Key Points to Cover** (600-900 words):
- Operating system setup (Windows/Mac/Linux)
- IDE/Editor installation and configuration (VS Code with 30+ extensions)
- Programming language/runtime installation (exact versions)
- Package manager setup and configuration
- Database installation (PostgreSQL/MySQL/MongoDB)
- Cache server installation (Redis, Memcached)
- Message queue setup (RabbitMQ, Kafka) if needed
- Docker Desktop installation and configuration
- Git configuration (user, SSH keys, GPG signing)

**Complete Commands Needed** (200-300 lines):
```bash
# EVERY installation command for Windows/Mac/Linux
# Node.js installation
choco install nodejs-lts --version=18.17.0  # Windows
brew install node@18  # Mac
# ... complete commands for ALL tools

# VS Code extensions (list 30+)
code --install-extension dbaeumer.vscode-eslint
code --install-extension esbenp.prettier-vscode
# ... ALL extensions

# PostgreSQL setup
# ... complete installation and initialization

# Redis setup  
# ... complete installation and configuration

# Docker setup
# ... complete installation

# Git configuration
git config --global user.name "Your Name"
# ... ALL git configurations
```

**Configuration Files Needed** (300+ lines total):
1. VS Code settings.json (100+ lines with ALL settings)
2. .gitconfig (30+ lines with aliases and settings)
3. Terminal profile configurations
4. Environment PATH setup

**Verification Steps**:
- Commands to verify each tool is installed
- Version check commands
- Connectivity tests

**Troubleshooting** (list 10-15 common issues):
- "Node not found" â†’ Solution
- "PostgreSQL won't start" â†’ Solution
- ... (10-15 issues with complete solutions)

### 2.2 Day 2: Project Initialization & Configuration
**Key Points to Cover** (800-1,200 words):
- Project folder creation (complete mkdir commands)
- Git repository initialization
- Package manager initialization (npm/pip/maven)
- Dependency installation (list ALL 50-100 dependencies)
- Configuration file creation (10-15 config files)
- Environment variable setup
- Initial commit and push

**Complete Commands Needed** (300-500 lines):
```bash
# Create project structure
mkdir -p backend/src/controllers backend/src/services backend/src/models backend/src/middleware
# ... EVERY folder creation command (50+ folders)

# Initialize package managers
npm init -y
# ... complete initialization

# Install ALL dependencies
npm install express@4.18.2 cors@2.8.5 helmet@7.0.0 ...
# List ALL 50-100 dependencies with exact versions
```

**Configuration Files Needed - COMPLETE CONTENTS** (1,000-2,000 lines total):
1. **package.json** - COMPLETE with all scripts, dependencies (200-300 lines)
2. **tsconfig.json** or equivalent - COMPLETE configuration (100+ lines)
3. **.env.example** - ALL 50-100 environment variables with descriptions
4. **.eslintrc.js** - COMPLETE linting rules (100+ lines)
5. **.prettierrc** - Complete code formatting config
6. **docker-compose.yml** - ALL services configured (200-300 lines)
7. **Dockerfile** - Multi-stage production build (80-120 lines)
8. **.dockerignore** - Complete ignore patterns
9. **.gitignore** - ALL patterns for Node/Python/Java
10. **README.md** - Complete project documentation (500+ words)
11. **jest.config.js** or equivalent - Complete test configuration
12. **.editorconfig** - Editor consistency
13. **renovate.json** or dependabot.yml - Dependency management
14. **LICENSE** - Complete license file
15. **CONTRIBUTING.md** - Contribution guidelines

For EACH config file, specify:
- Complete file contents (no placeholders!)
- Purpose of each section
- Customization points

### 2.3 Days 3-5: Database Design & Implementation
[Continue with similar extreme detail for Days 3-5]

## PHASE 3: DATABASE IMPLEMENTATION (Week 2)
**Target**: 3,000-4,000 words | Code: 2,000-3,000 lines | Duration: Week 2

### 3.1 Complete Database Schema Design
**Key Points to Cover** (800-1,200 words):
- Entity relationship design (15-30 tables)
- Normalization strategy (3NF minimum)
- Indexing strategy (20-50+ indices)
- Constraint design (foreign keys, check constraints, unique)
- Data types and size considerations
- Migration strategy
- Seed data strategy

**Complete SQL Schema Needed** (1,500-2,500 lines):
```sql
-- Create database
CREATE DATABASE myapp_production;

-- Enable extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
CREATE EXTENSION IF NOT EXISTS "btree_gin";

-- Users table - COMPLETE
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    ... [EVERY column - 15-25 columns]
);

-- Create ALL indices
CREATE INDEX idx_users_email ON users(email) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(role);
... [10-20 indices per major table]

-- Repeat COMPLETE structure for ALL 15-30 tables:
-- users, user_sessions, posts, comments, categories,
-- likes, notifications, activity_logs, file_uploads,
-- orders, products, inventory, invoices, payments,
-- messages, conversations, etc.
[EVERY table with EVERY column, constraint, index]
```

**Migration Files Needed** (500-1,000 lines):
1. 001_initial_schema.sql - Complete initial tables
2. 002_add_indexes.sql - All performance indexes
3. 003_add_triggers.sql - Audit and automation triggers
4. 004_seed_reference_data.sql - Reference data
5. 005_add_full_text_search.sql - Search optimization

### 3.2 ORM Models Implementation
**Key Points to Cover** (600-800 words):
- Model design patterns
- Relationship definitions (one-to-many, many-to-many)
- Validation at model level
- Virtual fields and computed properties
- Model methods and helpers
- Serialization and deserialization

**Complete Model Code Needed** (1,500-2,500 lines):
```
COMPLETE User model (200-400 lines) with:
- Entity decorators and table mapping
- All field definitions with proper types
- All relationships (one-to-many, many-to-many)
- All methods (setPassword, verifyPassword, etc.)
- Complete validation logic
- Serialization methods

Repeat COMPLETE models for ALL 15-30 entities:
UserSession, Post, Comment, Category, Like, Notification, 
ActivityLog, FileUpload, Order, Product, etc.
Each model should be 100-400 lines, fully implemented
```

## PHASE 4: BACKEND IMPLEMENTATION (Weeks 2-4)
**Target**: 5,000-8,000 words | Code: 10,000-15,000 lines | Duration: 2-3 weeks

[Continue with same extreme detail level for:
- Server setup and configuration
- Middleware stack
- Authentication system (complete JWT + OAuth implementations)
- Authorization and RBAC
- API endpoints for ALL resources
- Service layer implementations
- Validation schemas
- Error handling
- Logging and monitoring setup]

## PHASE 5: FRONTEND IMPLEMENTATION (Weeks 3-5)
**Target**: 5,000-8,000 words | Code: 10,000-15,000 lines | Duration: 2-3 weeks

[Continue with extreme detail for:
- Framework setup
- Component library (30-50 components)
- Pages and views (20-30 pages)
- State management
- API client implementation
- Form handling
- Routing and navigation]

## PHASE 6: TESTING IMPLEMENTATION (Week 5-6)
**Target**: 3,000-5,000 words | Code: 5,000-10,000 lines | Duration: 1-2 weeks

[Extreme detail for all testing phases]

## PHASE 7: SECURITY IMPLEMENTATION (Throughout)
**Target**: 2,000-3,000 words | Code: 1,000-2,000 lines

[Complete security implementations]

## PHASE 8: DEVOPS & DEPLOYMENT (Week 6-7)
**Target**: 3,000-5,000 words | Code: 2,000-3,000 lines | Duration: 1-2 weeks

[Complete DevOps setup]

## PHASE 9: OPERATIONS & MAINTENANCE (Ongoing)
**Target**: 2,000-3,000 words | Code: 1,000-2,000 lines

[Operational procedures and runbooks]

## PHASE 10: DOCUMENTATION & HANDOFF (Week 7-8)
**Target**: 1,500-2,500 words | Code: 1,000-2,000 lines (OpenAPI specs)

[Complete documentation]

## ðŸ“Š OUTLINE METADATA
**Total Phases**: 10
**Total Sections**: 40-60
**Total Subsections**: 100-150
**Expected Final Document**:
- Word Count: 20,000-30,000+ words
- Code Lines: 3,000-5,000+ lines
- Configuration Files: 30-50+ complete files
- Code Examples: 50-100+ complete examples
- Troubleshooting Scenarios: 50+ issues with solutions

**Key Technologies from Research**:
[List 20-30 technologies identified in research]

**Critical Success Factors**:
- Complete, copy-pasteable code throughout
- Production-ready implementations only
- Full development lifecycle coverage
- Operational procedures included
- Comprehensive troubleshooting

ðŸš¨ CRITICAL: This outline must be SO DETAILED that an LLM can write a 20,000-30,000 word production-ready guide by following it. Include specific facts, exact code requirements, complete file lists, and comprehensive coverage of the entire development lifecycle from day 1 to production operations."""

        return self.generate_response(prompt, research_context, temperature=0.3, max_tokens=Config.DEEPSEEK_OUTLINE_MAX_TOKENS)
    
    def create_research_summary(self,
                               doc_type: str,
                               research_context: str,
                               user_prompt: str) -> LLMMessage:
        """Compress 128K research into 2-3K summary relevant to specific document"""
        
        prompt = f"""From the extensive research below, extract ONLY information relevant to: {doc_type}

PROJECT: {user_prompt}

FULL RESEARCH (100+ sources):
{research_context[:20000]}

YOUR TASK: Create a 2,000-3,000 token summary containing ONLY what's needed for writing this specific document type.

EXTRACT:
1. **Key Technical Facts**: Specific facts, best practices, recommendations
2. **Code Examples**: Relevant code patterns and examples
3. **Tool Recommendations**: Specific tools, libraries, frameworks mentioned
4. **Common Pitfalls**: Issues to avoid, debugging tips
5. **Configuration Details**: Setup steps, configuration examples
6. **Performance Tips**: Optimization recommendations
7. **Security Considerations**: Security best practices
8. **Source URLs**: Keep URLs for citations

OMIT:
- General/irrelevant information
- Duplicate information
- Off-topic content

OUTPUT FORMAT:
## Technical Facts
- Fact 1 [Source: URL]
- Fact 2 [Source: URL]

## Code Patterns
- Pattern 1: [description]
- Pattern 2: [description]

## Tools & Libraries
- Tool 1: [why and how to use]
- Tool 2: [why and how to use]

## Best Practices
- Practice 1: [description]
- Practice 2: [description]

This summary will be given to Ollama (24K context) for document writing."""

        return self.generate_response(prompt, research_context, temperature=0.2, max_tokens=3000)
    
    def review_document_accuracy(self,
                                document_content: str,
                                original_outline: str,
                                research_context: str,
                                doc_title: str) -> LLMMessage:
        """Review Ollama's document against research for technical accuracy"""
        
        prompt = f"""Review this implementation guide for TECHNICAL ACCURACY and COMPLETENESS.

DOCUMENT: {doc_title}

ORIGINAL OUTLINE:
{original_outline[:3000]}

DOCUMENT CONTENT (written by Ollama):
{document_content[:6000]}

RESEARCH CONTEXT (for verification):
{research_context[:10000]}

YOUR REVIEW CHECKLIST:
1. **Outline Adherence**: Did it cover all sections from outline?
2. **Technical Accuracy**: Are technical facts correct per research?
3. **Code Quality**: Are code examples correct and complete?
4. **Citations**: Are sources properly cited?
5. **Completeness**: Any missing subsections or examples?
6. **Configuration Files**: Are all needed configs included in full?

PROVIDE:
1. **Overall Assessment**: APPROVED or NEEDS REVISION
2. **Technical Corrections**: List any incorrect facts/code
3. **Missing Content**: What sections/examples are incomplete
4. **Citation Issues**: Missing or incorrect source citations
5. **Specific Improvements**: 3-5 concrete additions/fixes needed

Keep response under 5,000 tokens. Be specific and actionable."""

        return self.generate_response(prompt, research_context, temperature=0.3, max_tokens=5000)
    
    def generate_multiple_documents(self,
                                  user_prompt: str,
                                  research_context: str,
                                  conversation_summary: str) -> List[Dict[str, str]]:
        """Generate multiple specialized documents for comprehensive implementation"""
        
        documents = []
        
        # MASSIVE increase in max tokens for COMPREHENSIVE, PRODUCTION-READY documentation
        # These documents must be complete enough to build entire systems from scratch
        doc_max_tokens = Config.DEEPSEEK_COMPREHENSIVE_DOC_MAX_TOKENS  # 64K tokens per document
        logger.info(f"Generating comprehensive production-ready documents with {doc_max_tokens} max tokens each")
        
        try:
            # Document 1: System Architecture & Implementation Guide
            logger.info("Generating Document 1: System Architecture & Implementation")
            arch_prompt = f"""Create a COMPREHENSIVE, PRODUCTION-READY SYSTEM ARCHITECTURE & IMPLEMENTATION GUIDE that covers the COMPLETE SOFTWARE DEVELOPMENT LIFECYCLE for: {user_prompt}

RESEARCH CONTEXT: {research_context}
TECHNICAL DISCUSSION: {conversation_summary}

# FULL LIFECYCLE System Architecture & Implementation Guide

## PHASE 1: REQUIREMENTS & PLANNING (Week 1)

### 1.1 Requirements Analysis & Documentation
- **Functional Requirements**: Complete list (30-50 requirements) with acceptance criteria
- **Non-Functional Requirements**: Performance, scalability, security, usability targets
- **User Stories**: 20-30 detailed user stories with acceptance criteria
- **Use Cases**: Complete use case diagrams and descriptions
- **Business Rules**: Document all business logic and validation rules
- **Include complete requirements specification document template**

### 1.2 System Architecture Design
- **High-Level Architecture**: Complete architecture diagrams (textual/ASCII/Mermaid)
- **Component Architecture**: Every component, its responsibilities, and interfaces
- **Data Flow Diagrams**: Complete data flow with examples
- **Integration Points**: All external services, APIs, and dependencies
- **Technology Stack Justification**: Why each technology was chosen with alternatives
- **Scalability Design**: Load balancing, caching strategy, database sharding
- **Include complete architecture decision records (ADRs)**

### 1.3 Project Structure & Organization
```
Complete file/folder structure (show 100+ files):
/project-root
  /docs - All documentation
  /src or /app - Application source
    /components - Frontend components (list 20+ components)
    /services - Business logic services (list 15+ services)
    /models - Data models (list 10+ models)
    /controllers - API controllers (list 10+ controllers)
    /middleware - Auth, logging, error handling
    /utils - Helper functions
  /tests - Complete test structure
    /unit - Unit tests for each component
    /integration - Integration tests
    /e2e - End-to-end tests
  /config - All configuration files
  /scripts - Build, deployment, migration scripts
  /infrastructure - Docker, K8s, Terraform configs
  /database - Migrations, seeds, schemas
```

## PHASE 2: ENVIRONMENT SETUP & INITIALIZATION (Week 1-2)

### 2.1 Development Environment Setup
**Complete installation commands for:**
- Operating system setup (Windows/Mac/Linux)
- IDE/Editor configuration (VS Code with 20+ extensions)
- Programming language/runtime (Node.js, Python, Java - exact versions)
- Package managers (npm, pip, maven - configuration)
- Database installation (PostgreSQL/MySQL/MongoDB - complete setup)
- Cache servers (Redis, Memcached - installation and config)
- Message queues (RabbitMQ, Kafka - if needed)
- Version control (Git configuration, .gitignore, hooks)

### 2.2 Project Initialization - COMPLETE CODE
```
Every single command with explanations:
# Initialize project
npm init -y  # or equivalent
git init
git remote add origin <url>

# Install ALL dependencies (list 50+ packages with versions)
npm install express@4.18.2 ... (complete list)

# Create COMPLETE configuration files:
```

**Configuration Files (Include FULL content):**
1. **package.json** - Complete with all scripts, dependencies, devDependencies
2. **tsconfig.json** or equivalent - Full TypeScript/Babel configuration
3. **.env.example** - Every environment variable needed
4. **.eslintrc.js** - Complete linting rules
5. **.prettierrc** - Code formatting
6. **docker-compose.yml** - All services configured
7. **Dockerfile** - Multi-stage build
8. **.dockerignore** - Optimize builds
9. **.gitignore** - All patterns
10. **README.md** - Complete project documentation

## PHASE 3: DATABASE DESIGN & IMPLEMENTATION (Week 2)

### 3.1 Complete Database Schema
**Provide FULL SQL for ALL tables (15-30 tables minimum):**
```sql
-- Users table with ALL columns
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    role VARCHAR(50) DEFAULT 'user',
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP,
    metadata JSONB
);

-- Add indices
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Repeat for EVERY table (posts, comments, orders, products, etc.)
```

### 3.2 ORM Models - Complete Implementations
**Provide COMPLETE model code for ALL entities:**
Specification: Complete User model implementation (200-400 lines) with:
- Entity decorators and table mapping
- All field definitions with proper types and decorators
- All column constraints (unique, nullable, defaults)
- All relationships (OneToMany, ManyToOne, ManyToMany)
- All methods (setPassword, verifyPassword, serialization)
- Complete validation logic
- Hooks and lifecycle methods

Repeat COMPLETE models for ALL 15-30 entities including:
UserSession, Post, Comment, Category, Like, Notification, ActivityLog, 
FileUpload, Order, Product, Inventory, Payment, Message, etc.
Each model 100-400 lines with full implementation.

### 3.3 Database Migrations - Complete Files
**Include COMPLETE migration files for:**
- Initial schema creation (full migration with up/down)
- Every schema change
- Seed data for development and testing

## PHASE 4: BACKEND IMPLEMENTATION (Week 2-4)

### 4.1 Server Setup & Configuration - COMPLETE CODE
```typescript
// server.ts - COMPLETE implementation (200-300 lines)
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
// ... all imports

const app = express();

// Complete middleware setup
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors({
    origin: process.env.CORS_ORIGIN,
    credentials: true
}));
app.use(helmet());
// ... all security middleware

// Complete route registration
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
// ... all routes (15-30 route files)

// Complete error handling
app.use(errorHandler);

// Include COMPLETE server startup code
```

### 4.2 Authentication System - COMPLETE IMPLEMENTATION
**JWT Authentication (500-800 lines total):**

Provide complete authentication system with:
- auth.middleware: Complete JWT verification logic
- auth.controller: ALL endpoints (register, login, refreshToken, logout, forgotPassword, resetPassword)
- auth.service: Complete business logic with password hashing, token generation, validation
- Each endpoint should be 50-100 lines with full error handling
- Include rate limiting, session management, email verification
- Include password reset flow with token expiration
- Include refresh token rotation for security

### 4.3 API Endpoints - COMPLETE FOR ALL RESOURCES
**For EACH resource (Users, Posts, Products, Orders, etc.) provide COMPLETE:**

Specification for users.controller (300-500 lines):
- GET /api/users - List with pagination, filtering, sorting
- GET /api/users/:id - Get single user with error handling, permission checks
- POST /api/users - Create user with validation, sanitization
- PUT /api/users/:id - Update user with complete update logic
- PATCH /api/users/:id - Partial update
- DELETE /api/users/:id - Soft delete with cascade handling
- GET /api/users/:id/posts - Get user's posts
- GET /api/users/:id/activity - Get activity log
- POST /api/users/:id/avatar - Upload avatar
- DELETE /api/users/:id/avatar - Remove avatar
(10-15 endpoints per resource with full implementations)

Repeat for EVERY resource (10-20 resources): Users, Posts, Comments, Categories, Products, Orders, etc.

### 4.4 Business Logic Layer - COMPLETE SERVICES
**Service layer for ALL business logic (2000-3000 lines total):**
```typescript
// users.service.ts - COMPLETE (200-300 lines)
export class UserService {
    async create(userData) {
        // Complete creation with validation, transformation
    }
    
    async update(id, updates) {
        // Complete update with optimistic locking
    }
    
    async delete(id) {
        // Complete deletion with related data handling
    }
    
    async search(criteria) {
        // Complete search with filtering, pagination
    }
    
    // ALL business methods
}

// Repeat for ALL services (10-20 services)
```

### 4.5 Data Validation - COMPLETE SCHEMAS
**Validation schemas for EVERY endpoint:**
```typescript
// validation/user.schema.ts - COMPLETE
export const createUserSchema = Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().min(8).regex(/[A-Z]/).regex(/[0-9]/).required(),
    firstName: Joi.string().min(2).max(50).required(),
    // ... EVERY field with detailed validation
});

// Include schemas for ALL resources and operations (100+ schemas)
```

## PHASE 5: FRONTEND IMPLEMENTATION (Week 3-5)

### 5.1 Frontend Framework Setup - COMPLETE
**Complete setup commands and configuration:**
```bash
# Create React/Vue/Angular app
npx create-react-app my-app --template typescript

# Install ALL dependencies (50+ packages)
npm install @mui/material @emotion/react ... (complete list)
```

### 5.2 Component Library - COMPLETE COMPONENTS
**Provide COMPLETE code for ALL components (30-50 components):**
```typescript
// Header.tsx - COMPLETE (100-200 lines)
import React from 'react';
import { AppBar, Toolbar, ... } from '@mui/material';

export const Header: React.FC = () => {
    // Complete implementation with all features
    return (
        // Complete JSX with all elements
    );
};

// Button.tsx, Input.tsx, Modal.tsx, Table.tsx, Form.tsx, etc.
// Include ALL reusable components (30+ components)
```

### 5.3 Pages/Views - COMPLETE IMPLEMENTATIONS
**Every page with COMPLETE code (20-30 pages):**
```typescript
// pages/UserList.tsx - COMPLETE (300-500 lines)
export const UserList: React.FC = () => {
    // Complete state management
    // Complete data fetching
    // Complete rendering with pagination, filtering, sorting
    // Complete CRUD operations
    // Complete error handling
    // Complete loading states
};

// Login, Register, Dashboard, Profile, Settings, etc.
// Include EVERY page (20-30 pages) with COMPLETE implementations
```

### 5.4 State Management - COMPLETE SETUP
**Redux/MobX/Context - COMPLETE implementation:**
```typescript
// store/index.ts - COMPLETE store configuration
// slices for EVERY feature (10-20 slices)
// Complete action creators, reducers, selectors
```

### 5.5 API Integration - COMPLETE CLIENT
```typescript
// api/client.ts - COMPLETE API client (500+ lines)
// Methods for EVERY endpoint (100+ methods)
// Complete error handling, retries, caching
```

## PHASE 6: TESTING IMPLEMENTATION (Week 5-6)

### 6.1 Unit Testing - COMPLETE TEST SUITES
**Unit tests for EVERY component/service/function:**
```typescript
// tests/unit/user.service.test.ts - COMPLETE (300-500 lines)
describe('UserService', () => {
    // 30-50 test cases covering ALL scenarios
    it('should create user with valid data', async () => {
        // Complete test implementation
    });
    
    // ... ALL test cases for this service
});

// Include tests for ALL 50-100 units (3000-5000 lines total)
```

### 6.2 Integration Testing - COMPLETE SUITES
**Integration tests for ALL API endpoints:**
```typescript
// tests/integration/users.api.test.ts - COMPLETE (500-800 lines)
// Test EVERY endpoint with multiple scenarios
// Database setup/teardown
// Authentication testing
// Error scenario testing
```

### 6.3 E2E Testing - COMPLETE USER FLOWS
**Cypress/Playwright tests for ALL user journeys:**
```typescript
// e2e/user-registration.spec.ts - COMPLETE (200-300 lines)
// Complete user flows (15-20 scenarios)
```

## PHASE 7: DEPLOYMENT & DEVOPS (Week 6-7)

### 7.1 Docker Configuration - COMPLETE FILES
**Dockerfile for EVERY service:**
```dockerfile
# Backend Dockerfile - COMPLETE multi-stage build
FROM node:18-alpine AS builder
# ... complete builder stage

FROM node:18-alpine AS production
# ... complete production stage
# ALL configuration, security hardening
```

**docker-compose.yml - COMPLETE STACK:**
```yaml
version: '3.8'
services:
  backend:
    # Complete configuration
  frontend:
    # Complete configuration
  database:
    # Complete configuration
  redis:
    # Complete configuration
  # ALL services with complete config (10-15 services)
```

### 7.2 CI/CD Pipeline - COMPLETE CONFIGURATION
**GitHub Actions - COMPLETE workflows:**
```yaml
# .github/workflows/ci.yml - COMPLETE (200-300 lines)
name: CI/CD Pipeline

on: [push, pull_request]

jobs:
  test:
    # Complete test job
  build:
    # Complete build job
  deploy:
    # Complete deployment job
  # ALL jobs with complete configuration
```

### 7.3 Cloud Deployment - COMPLETE SCRIPTS
**AWS/GCP/Azure - COMPLETE deployment:**
```bash
# deploy.sh - COMPLETE deployment script (300-500 lines)
# Terraform/CloudFormation - COMPLETE infrastructure as code
```

### 7.4 Monitoring & Logging - COMPLETE SETUP
**Logging configuration:**
```typescript
// logger.ts - COMPLETE Winston/Pino setup
// Monitoring setup - Complete Prometheus/Grafana config
// Error tracking - Complete Sentry integration
```

## PHASE 8: SECURITY IMPLEMENTATION (Throughout)

### 8.1 Security Best Practices - COMPLETE IMPLEMENTATIONS
- **Input Validation**: ALL validation rules implemented
- **SQL Injection Prevention**: Parameterized queries EVERYWHERE
- **XSS Prevention**: Output encoding and CSP headers
- **CSRF Protection**: CSRF tokens implemented
- **Rate Limiting**: Complete rate limiter configuration
- **Data Encryption**: Encryption for sensitive data
- **Secrets Management**: Vault/KMS integration
- **Security Headers**: Complete Helmet.js configuration
- **HTTPS Configuration**: SSL/TLS setup
- **Include COMPLETE security middleware (500+ lines)**

### 8.2 Authentication & Authorization - PRODUCTION-READY
- **JWT Implementation**: Complete with refresh tokens
- **OAuth 2.0**: Complete Google/GitHub/Facebook integration
- **RBAC**: Complete role-based access control
- **Permission System**: Granular permissions (50+ permissions)
- **Include COMPLETE auth system (1000+ lines)**

## PHASE 9: OPERATIONS & MAINTENANCE (Ongoing)

### 9.1 Operational Runbooks
**Complete procedures for:**
- Deployment (step-by-step with rollback)
- Scaling (horizontal and vertical)
- Backup and restore (complete scripts)
- Disaster recovery (complete plans)
- Incident response (complete playbooks)
- Database maintenance (vacuum, reindex, optimize)
- Certificate renewal (automated process)
- Log rotation and archival
- **Include 15-20 complete runbooks (200-300 lines each)**

### 9.2 Monitoring & Alerting
**Complete monitoring setup:**
- Application metrics (CPU, memory, requests)
- Business metrics (users, transactions, revenue)
- Error rates and types
- Database performance
- API response times
- Complete Prometheus/Grafana dashboards
- Complete PagerDuty/Opsgenie alert configuration
- **Include complete monitoring config (500+ lines)**

### 9.3 Troubleshooting Guide
**50+ common issues with solutions:**
- "Database connection refused" - Complete diagnosis and fix
- "High CPU usage" - Complete troubleshooting steps
- "Slow API responses" - Performance profiling and optimization
- "Authentication failures" - Complete debugging guide
- **Include complete troubleshooting playbook (1000+ lines)**

### 9.4 Performance Optimization
**Complete optimization guide:**
- Database query optimization (20+ examples)
- Caching strategies (Redis implementation)
- Code optimization (profiling and fixes)
- Frontend optimization (lazy loading, code splitting)
- **Include before/after code examples (500+ lines)**

## PHASE 10: DOCUMENTATION & HANDOFF (Week 7-8)

### 10.1 API Documentation - COMPLETE
**OpenAPI/Swagger spec for ALL endpoints:**
```yaml
# swagger.yaml - COMPLETE (2000-3000 lines)
# Document ALL 100+ endpoints with:
# - Request/response schemas
# - Example requests
# - Error responses
# - Authentication requirements
```

### 10.2 Developer Documentation
- Architecture overview
- Setup guide
- Development workflow
- Testing guide
- Deployment guide
- Troubleshooting guide
- **Complete developer handbook (100+ pages worth)**

### 10.3 User Documentation
- User guides for each feature
- Admin documentation
- API documentation for integrators
- **Complete user manual (50+ pages worth)**

## APPENDICES

### A. Environment Variables
**Complete list of ALL environment variables (50-100 variables):**
```bash
# Database
DATABASE_URL=postgresql://...
DATABASE_POOL_SIZE=20
DATABASE_TIMEOUT=5000

# ... EVERY variable with description and example
```

### B. Dependencies
**Complete dependency list with versions and justifications:**
- Production dependencies (50-100 packages)
- Development dependencies (30-50 packages)
- Why each was chosen
- Security considerations
- License compatibility

### C. Code Examples Library
**100+ code examples for common tasks:**
- Connecting to database
- Making API requests
- Handling file uploads
- Sending emails
- Processing payments
- Generating PDFs
- ... (100+ examples)

### D. Checklists
- Pre-deployment checklist (50+ items)
- Security audit checklist (100+ items)
- Code review checklist (30+ items)
- Testing checklist (50+ items)

CRITICAL REQUIREMENTS:
1. This document must be 40,000-60,000+ tokens (use ALL {doc_max_tokens} available)
2. Include COMPLETE, RUNNABLE code for EVERYTHING - no placeholders or "..." omissions
3. Cover ENTIRE development lifecycle from requirements to operations
4. Every configuration file must be COMPLETE and production-ready
5. Include AT LEAST 100 code examples with 15,000+ lines of actual code
6. This should be sufficient to build the ENTIRE system from scratch
7. A developer should be able to copy-paste code and follow instructions to create working software
8. Include ALL error handling, validation, security, testing, deployment
9. No summaries - provide FULL implementations
10. Think "production deployment documentation" not "tutorial"

This is COMPREHENSIVE, ENTERPRISE-LEVEL documentation. Use EVERY available token to provide complete, production-ready implementations."""

            arch_doc = self.generate_response(arch_prompt, research_context, temperature=0.3, max_tokens=doc_max_tokens)
            documents.append({
                "title": "System Architecture & Technical Specifications",
                "filename": "01_system_architecture.md",
                "content": arch_doc.content,
                "category": "architecture"
            })
            logger.info(f"Document 1 generated successfully ({len(arch_doc.content)} chars)")
        except Exception as e:
            logger.error(f"Failed to generate System Architecture document: {e}")
            documents.append({
                "title": "System Architecture & Technical Specifications",
                "filename": "01_system_architecture.md",
                "content": f"# System Architecture\n\n*Error generating document: {str(e)}*\n\nPlease retry or check the logs for details.",
                "category": "architecture"
            })

        try:
            # Document 2: Step-by-Step Implementation Guide
            logger.info("Generating Document 2: Step-by-Step Implementation Guide")
            impl_prompt = f"""Create a DETAILED STEP-BY-STEP IMPLEMENTATION GUIDE for: {user_prompt}

RESEARCH CONTEXT: {research_context}
TECHNICAL DISCUSSION: {conversation_summary}

# Step-by-Step Implementation Guide

## 1. ENVIRONMENT SETUP (Day 1)
### Development Machine Setup
- **Install required tools**: Node.js/Python/Ruby (include version numbers and installation commands)
- **IDE/Editor setup**: VS Code extensions, settings.json configuration
- **Database installation**: PostgreSQL/MySQL/MongoDB setup commands and configuration
- **Docker setup**: Installation and basic configuration
- **Include complete commands for each step**

### Project Initialization
- **Create project structure**: mkdir commands and folder organization
- **Initialize package manager**: npm init, pip setup, bundle init with configurations
- **Set up Git repository**: git init, .gitignore template, initial commit
- **Configure linting and formatting**: ESLint/Prettier/Black configuration files
- **Include all configuration file contents**

## 2. BACKEND IMPLEMENTATION (Weeks 1-4)
### Database Setup
- **Schema creation**: Complete SQL/NoSQL schema definitions with CREATE statements
- **Migration setup**: Migration framework installation and first migration file
- **Seed data**: Test data scripts and population procedures
- **Connection configuration**: Database connection code with error handling
- **Include complete migration files and seed scripts**

### API Development
- **Server setup**: Express/Flask/Rails server initialization code
- **Routing configuration**: Complete route definitions with middleware
- **Controller implementation**: CRUD operations with full code examples
- **Authentication**: JWT/OAuth implementation with complete auth middleware code
- **Error handling**: Centralized error handling middleware with examples
- **Include complete API endpoint implementations**

### Business Logic
- **Service layer**: Business logic classes with full implementations
- **Data validation**: Input validation with Joi/Pydantic/validator examples
- **Database operations**: Repository pattern implementations with queries
- **Transaction handling**: Transaction management code examples
- **Include complete service class implementations**

## 3. FRONTEND IMPLEMENTATION (Weeks 3-6)
### UI Framework Setup
- **React/Vue/Angular setup**: Create-react-app or equivalent with configurations
- **State management**: Redux/Vuex/NgRx setup with store configuration
- **Router configuration**: React-router/Vue-router setup with route definitions
- **API client**: Axios/Fetch configuration with interceptors
- **Include complete setup files and configurations**

### Component Development
- **Component structure**: Reusable component examples with props/state
- **Form handling**: Complete form components with validation
- **Data fetching**: API integration with loading/error states
- **Authentication UI**: Login/signup components with JWT handling
- **Include 5-10 complete component implementations**

### Styling
- **CSS framework setup**: Tailwind/Bootstrap/Material-UI configuration
- **Theme configuration**: Custom theme setup and variables
- **Responsive design**: Media query examples and mobile-first approach
- **Include complete styling configuration and examples**

## 4. TESTING IMPLEMENTATION (Throughout)
### Unit Testing
- **Test framework setup**: Jest/Pytest/RSpec configuration
- **Test structure**: Complete test file examples for each component type
- **Mock data**: Test fixtures and mock implementations
- **Coverage setup**: Coverage reporting configuration
- **Include 10+ complete test examples**

### Integration Testing
- **API testing**: Supertest/Postman/HTTPie examples
- **Database testing**: Test database setup and teardown
- **End-to-end testing**: Cypress/Selenium setup and test examples
- **Include complete integration test suites**

## 5. DEPLOYMENT & OPERATIONS (Weeks 7-8)
### Docker Configuration
- **Dockerfile**: Complete Dockerfile for each service
- **Docker Compose**: Full docker-compose.yml with all services
- **Environment variables**: .env template and configuration
- **Include complete Docker setup**

### CI/CD Pipeline
- **GitHub Actions/GitLab CI**: Complete pipeline configuration files
- **Build scripts**: npm scripts, Makefile, or automation scripts
- **Deployment scripts**: Deploy-to-production procedures
- **Include complete CI/CD configurations**

### Production Setup
- **Cloud deployment**: AWS/GCP/Azure deployment procedures and terraform/CloudFormation
- **Domain and SSL**: DNS configuration and Let's Encrypt setup
- **Monitoring**: New Relic/Datadog setup and alerting configuration
- **Backups**: Automated backup scripts and restoration procedures
- **Include step-by-step deployment commands**

## 6. TROUBLESHOOTING & COMMON ISSUES
- **Database connection errors**: Solutions with code examples
- **CORS issues**: Configuration fixes with examples
- **Authentication problems**: Debugging procedures and fixes
- **Performance bottlenecks**: Optimization techniques with before/after code
- **Include 10-15 common issues with solutions**

IMPORTANT: This should be a COMPLETE TUTORIAL that a developer can follow step-by-step to build the entire system. Include every command, every configuration file, and every code example needed."""

            impl_doc = self.generate_response(impl_prompt, research_context, temperature=0.3, max_tokens=doc_max_tokens)
            documents.append({
                "title": "Implementation Guide & Development Plan",
                "filename": "02_implementation_guide.md",
                "content": impl_doc.content,
                "category": "implementation"
            })
            logger.info(f"Document 2 generated successfully ({len(impl_doc.content)} chars)")
        except Exception as e:
            logger.error(f"Failed to generate Implementation Guide: {e}")
            documents.append({
                "title": "Implementation Guide & Development Plan",
                "filename": "02_implementation_guide.md",
                "content": f"# Implementation Guide\n\n*Error generating document: {str(e)}*\n\nPlease retry or check the logs for details.",
                "category": "implementation"
            })

        try:
            # Document 3: Security, Testing & Operations Implementation
            logger.info("Generating Document 3: Security, Testing & Operations Implementation")
            ops_prompt = f"""Create a COMPREHENSIVE SECURITY, TESTING & OPERATIONS IMPLEMENTATION GUIDE for: {user_prompt}

RESEARCH CONTEXT: {research_context}
TECHNICAL DISCUSSION: {conversation_summary}

# Security, Testing & Operations Implementation Guide

## 1. SECURITY IMPLEMENTATION WITH CODE
### Authentication System
- **JWT Implementation**: Complete authentication middleware with token generation/verification
- **OAuth 2.0 Setup**: Full OAuth flow implementation with provider integration
- **Password Security**: Bcrypt/Argon2 implementation with salting and hashing code
- **Session Management**: Session store setup with Redis and security configurations
- **Include complete authentication module code (200-300 lines)**

### Authorization & Access Control
- **RBAC Implementation**: Role-based access control with complete middleware
- **Permission System**: Permission checking decorators and guards with examples
- **API Key Management**: API key generation, storage, and validation code
- **Include complete authorization system (150-200 lines)**

### Security Configurations
- **Security Headers**: Helmet.js/Flask-Talisman configuration with all headers
- **CORS Setup**: Complete CORS configuration with whitelist management
- **Rate Limiting**: Express-rate-limit/Flask-Limiter with Redis store
- **SQL Injection Prevention**: Parameterized queries and ORM usage examples
- **XSS Protection**: Input sanitization and output encoding code
- **CSRF Protection**: CSRF token implementation with validation
- **Include 10+ security configuration files**

### Encryption Implementation
- **Data at Rest**: Database encryption setup with AWS KMS/Azure Key Vault
- **Data in Transit**: TLS/SSL configuration for HTTPS enforcement
- **File Encryption**: File upload encryption with crypto libraries
- **Environment Variables**: Secure secrets management with HashiCorp Vault
- **Include complete encryption utilities (100-150 lines)**

## 2. COMPREHENSIVE TESTING WITH EXAMPLES
### Unit Testing Suite
- **Test Framework Setup**: Jest/Pytest/RSpec configuration files
- **Test Structure**: 15-20 complete unit test examples for:
  - Controller tests with mocked dependencies
  - Service layer tests with test data
  - Utility function tests with edge cases
  - Database model tests with fixtures
- **Mocking Examples**: Complete mock implementations for external services
- **Test Coverage**: Istanbul/Coverage.py configuration for 80%+ coverage
- **Include 500-1000 lines of test code examples**

### Integration Testing
- **API Integration Tests**: Complete test suite for all endpoints
  - Authentication flow tests (login, logout, token refresh)
  - CRUD operation tests for each resource
  - Error handling tests (400, 401, 403, 404, 500)
  - File upload/download tests
- **Database Integration Tests**: Transaction tests, rollback tests, migration tests
- **Third-party Integration Tests**: Mock external APIs with nock/responses
- **Include 300-500 lines of integration test code**

### End-to-End Testing
- **Cypress/Selenium Setup**: Complete E2E test configuration
- **User Flow Tests**: 10-15 complete test scenarios:
  - User registration and login flow
  - Main application workflows
  - Error recovery scenarios
  - Mobile responsive tests
- **Visual Regression Testing**: Percy/BackstopJS setup and configuration
- **Include complete E2E test suite (400-600 lines)**

### Performance & Load Testing
- **Load Testing Scripts**: K6/Locust scripts for API endpoints
- **Performance Benchmarks**: Baseline performance metrics and thresholds
- **Database Query Profiling**: EXPLAIN query analysis and optimization
- **Frontend Performance**: Lighthouse CI configuration and thresholds
- **Include complete load testing scripts (200-300 lines)**

## 3. DEPLOYMENT & OPERATIONS IMPLEMENTATIONS
### Docker & Container Setup
- **Complete Dockerfiles**: Production-ready Dockerfiles for all services (frontend, backend, database)
- **Docker Compose**: Full docker-compose.yml with networking, volumes, health checks
- **Multi-stage Builds**: Optimized build process for smaller images
- **Docker Networking**: Service discovery and inter-container communication
- **Include all Docker files (300-400 lines total)**

### CI/CD Pipeline Implementation
- **GitHub Actions**: Complete workflow files for:
  - Pull request checks (lint, test, build)
  - Automated deployment to staging/production
  - Security scanning (Snyk, Trivy)
  - Performance testing
- **GitLab CI/Jenkins**: Alternative pipeline configurations
- **Build Scripts**: Package.json scripts, Makefiles, deployment scripts
- **Include complete CI/CD configurations (400-500 lines)**

### Cloud Infrastructure
- **Kubernetes Manifests**: Complete K8s deployments, services, ingress, configmaps
- **Terraform/Pulumi**: Infrastructure as Code for AWS/GCP/Azure
- **Helm Charts**: Complete Helm chart for application deployment
- **Cloud Functions**: Serverless function examples for background tasks
- **Include complete infrastructure code (500-800 lines)**

### Monitoring & Logging
- **Application Logging**: Winston/Structlog setup with log levels and formatting
- **Centralized Logging**: ELK Stack/Loki configuration with log aggregation
- **Application Monitoring**: Prometheus metrics endpoints and custom metrics
- **Distributed Tracing**: Jaeger/Zipkin integration with trace context
- **Alerting Rules**: Prometheus AlertManager rules for critical issues
- **Dashboard Configuration**: Grafana dashboards JSON export
- **Include complete monitoring setup (300-500 lines)**

### Database Operations
- **Backup Scripts**: Automated database backup scripts (pg_dump, mongodump)
- **Restore Procedures**: Complete restoration procedures with commands
- **Migration Scripts**: Database migration files with rollback support
- **Replication Setup**: Primary-replica configuration for PostgreSQL/MySQL
- **Include complete database operational scripts (200-300 lines)**

## 4. PERFORMANCE OPTIMIZATION IMPLEMENTATIONS
### Caching Implementation
- **Redis Setup**: Complete Redis configuration and connection pooling
- **Cache Strategies**: Cache-aside, write-through implementations with code
- **Cache Invalidation**: Cache invalidation patterns and implementations
- **API Response Caching**: HTTP caching headers and CDN configuration
- **Include complete caching layer (200-300 lines)**

### Database Optimization
- **Index Creation**: Optimal index definitions with analysis
- **Query Optimization**: Before/after examples of slow queries
- **Connection Pooling**: PgBouncer/connection pool configuration
- **N+1 Query Solutions**: Eager loading and join optimization examples
- **Include 20+ optimization examples**

### Application Performance
- **Code Profiling**: Profiling setup and hotspot identification
- **Async/Await Optimization**: Concurrent request handling examples
- **Memory Leak Detection**: Memory profiling and leak prevention
- **Bundle Optimization**: Webpack/Vite configuration for smaller bundles
- **Include optimization code examples (300-400 lines)**

## 5. OPERATIONAL RUNBOOKS & PROCEDURES
### Production Runbooks
- **Deployment Procedure**: Step-by-step deployment commands with rollback
- **Incident Response**: Incident handling procedures with commands
- **Database Maintenance**: Vacuum, analyze, reindex procedures
- **Certificate Renewal**: SSL certificate renewal with Let's Encrypt
- **Scaling Procedures**: Horizontal and vertical scaling commands
- **Include 10-15 complete runbooks**

### Troubleshooting Guide
- **Common Issues**: 25+ issues with symptoms, diagnosis, and solutions
  - "500 Internal Server Error" - debugging steps with log analysis
  - "Database connection refused" - connection troubleshooting
  - "High memory usage" - memory profiling and optimization
  - "Slow API responses" - performance profiling steps
- **Debug Commands**: Complete command-line debugging toolkit
- **Log Analysis**: Log parsing commands and patterns to search for
- **Include complete troubleshooting playbook**

IMPORTANT: This should be a PRODUCTION-READY operations guide with every security configuration, test file, deployment script, and monitoring setup needed to run the system in production. Include complete, runnable code for everything."""

            ops_doc = self.generate_response(ops_prompt, research_context, temperature=0.3, max_tokens=doc_max_tokens)
            documents.append({
                "title": "Security, Testing & Operations Guide",
                "filename": "03_security_testing_ops.md",
                "content": ops_doc.content,
                "category": "operations"
            })
            logger.info(f"Document 3 generated successfully ({len(ops_doc.content)} chars)")
        except Exception as e:
            logger.error(f"Failed to generate Security & Operations Guide: {e}")
            documents.append({
                "title": "Security, Testing & Operations Guide",
                "filename": "03_security_testing_ops.md",
                "content": f"# Security, Testing & Operations\n\n*Error generating document: {str(e)}*\n\nPlease retry or check the logs for details.",
                "category": "operations"
            })

        # Document 4: API Documentation & Integration Guide (if content is substantial enough)
        if len(conversation_summary) > 20000:  # Only create if there's substantial technical discussion
            try:
                logger.info("Generating Document 4: API Documentation & Integration Implementation")
                api_prompt = """Create a COMPLETE API DOCUMENTATION & INTEGRATION IMPLEMENTATION GUIDE for: {prompt}

RESEARCH CONTEXT: {context}
TECHNICAL DISCUSSION: {discussion}

RESEARCH CONTEXT: {research_context}
TECHNICAL DISCUSSION: {conversation_summary}

# API Documentation & Integration Implementation Guide

## 1. COMPLETE API ENDPOINT SPECIFICATIONS
For EVERY API endpoint, provide:

### Authentication Endpoints
**POST /api/auth/register**
- **Description**: User registration endpoint
- **Request Headers**: Content-Type: application/json
- **Request Body Schema**:
  ```json
  {{
    "email": "string (required, email format)",
    "password": "string (required, min 8 chars)",
    "name": "string (required)"
  }}
  ```
- **Success Response (201)**:
  ```json
  {{
    "user": {{"id": 123, "email": "user@example.com", "name": "John Doe"}},
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }}
  ```
- **Error Responses**:
  - 400: {{"error": "Email already exists"}}
  - 422: {{"error": "Invalid email format"}}
- **cURL Example**:
  ```bash
  curl -X POST https://api.example.com/auth/register \
    -H "Content-Type: application/json" \
    -d '{{"email":"user@example.com","password":"secure123","name":"John Doe"}}'
  ```
- **JavaScript Example**:
  ```javascript
  const response = await fetch('/api/auth/register', {{
    method: 'POST',
    headers: {{'Content-Type': 'application/json'}},
    body: JSON.stringify({{email, password, name}})
  }});
  const data = await response.json();
  ```
- **Python Example**:
  ```python
  response = requests.post('https://api.example.com/auth/register',
    json={{"email": "user@example.com", "password": "secure123", "name": "John Doe"}})
  data = response.json()
  ```

**Repeat this detailed format for ALL endpoints** (15-30 endpoints total):
- POST /api/auth/login
- POST /api/auth/logout
- POST /api/auth/refresh
- GET /api/users/me
- PUT /api/users/:id
- DELETE /api/users/:id
- GET /api/resources (with pagination, filtering, sorting)
- POST /api/resources
- GET /api/resources/:id
- PUT /api/resources/:id
- PATCH /api/resources/:id
- DELETE /api/resources/:id
- Plus any domain-specific endpoints

## 2. API CLIENT IMPLEMENTATIONS
### Complete JavaScript/TypeScript SDK
```typescript
// Complete 200-300 line SDK implementation
class ApiClient {{
  private baseUrl: string;
  private token: string | null = null;

  constructor(baseUrl: string) {{
    this.baseUrl = baseUrl;
  }}

  async register(email: string, password: string, name: string) {{
    // Complete implementation with error handling
  }}

  async login(email: string, password: string) {{
    // Complete implementation
  }}

  async getResource(id: number) {{
    // Complete implementation
  }}

  // Include ALL methods for ALL endpoints
}}
```

### Complete Python SDK
```python
# Complete 200-300 line Python client
class ApiClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.token = None
    
    def register(self, email: str, password: str, name: str) -> dict:
        # Complete implementation
        pass
    
    # Include ALL methods for ALL endpoints
```

### Complete Go SDK
```go
// Complete 200-300 line Go client
package apiclient

type Client struct {{
    BaseURL string
    Token   string
}}

func NewClient(baseURL string) *Client {{
    // Complete implementation
}}

// Include ALL methods for ALL endpoints
```

## 3. THIRD-PARTY INTEGRATIONS WITH CODE
### Stripe Payment Integration
- **Setup Code**: Complete Stripe SDK initialization
- **Payment Intent Creation**: Full implementation with error handling
- **Webhook Handler**: Complete webhook endpoint with signature verification
- **Test Mode Setup**: Test card numbers and testing procedures
- **Include 300-500 lines of integration code**

### AWS S3 File Upload Integration
- **S3 Client Setup**: Complete AWS SDK configuration
- **Pre-signed URL Generation**: Full implementation for secure uploads
- **Direct Upload Code**: Client-side and server-side upload examples
- **File Processing**: Image resizing, format conversion examples
- **Include 200-400 lines of integration code**

### SendGrid/Mailgun Email Integration
- **Email Client Setup**: Complete SDK initialization
- **Template System**: Email template examples (HTML + text)
- **Transactional Emails**: Order confirmation, password reset implementations
- **Bulk Email**: Newsletter sending with batching
- **Include 150-250 lines of email integration code**

### Twilio SMS/WhatsApp Integration
- **Twilio Setup**: Complete client initialization
- **SMS Sending**: SMS notification implementations
- **Two-Factor Authentication**: Implementation with Twilio Verify
- **WhatsApp Business**: WhatsApp message templates and sending
- **Include 150-250 lines of Twilio integration code**

### Redis Pub/Sub for Real-time Features
- **Redis Setup**: Pub/sub client configuration
- **Event Publishing**: Event emission code for different events
- **Event Subscription**: Event listener implementations
- **WebSocket Integration**: Socket.io with Redis adapter
- **Include 200-300 lines of pub/sub code**

## 4. DATA SCHEMAS & VALIDATION
### Complete JSON Schemas
```json
// User Schema
{{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {{
    "id": {{"type": "integer"}},
    "email": {{"type": "string", "format": "email"}},
    "name": {{"type": "string", "minLength": 1, "maxLength": 100}},
    "createdAt": {{"type": "string", "format": "date-time"}}
  }},
  "required": ["id", "email", "name", "createdAt"]
}}

// Include schemas for ALL data models (10-20 schemas)
```

### Validation Implementations
- **Joi Validation (Node.js)**: Complete validation schemas for all endpoints
- **Pydantic Models (Python)**: Complete Pydantic models with validators
- **Zod Schemas (TypeScript)**: Complete type-safe validation schemas
- **Include 200-400 lines of validation code**

## 5. OPENAPI/SWAGGER SPECIFICATION
```yaml
# Complete 500-1000 line OpenAPI 3.0 specification
openapi: 3.0.0
info:
  title: Project API
  version: 1.0.0
  description: Complete API documentation

servers:
  - url: https://api.example.com/v1
    description: Production server
  - url: http://localhost:3000/v1
    description: Development server

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    # Include ALL schemas
  
paths:
  # Include ALL endpoints with complete specs
  /auth/register:
    post:
      summary: Register new user
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RegisterRequest'
      responses:
        '201':
          description: User created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuthResponse'
  
  # Complete specification for ALL endpoints
```

## 6. POSTMAN COLLECTION & TESTING
- **Complete Postman Collection**: JSON export with all endpoints and examples
- **Environment Variables**: Dev, staging, production environment configs
- **Pre-request Scripts**: Auth token refresh scripts
- **Test Scripts**: Automated test assertions for each endpoint
- **Include complete Postman collection (500-800 lines JSON)**

## 7. WEBHOOK IMPLEMENTATIONS
### Webhook Endpoint
```javascript
// Complete webhook receiver implementation
app.post('/webhooks/stripe', async (req, res) => {{
  const sig = req.headers['stripe-signature'];
  // Complete implementation with:
  // - Signature verification
  // - Event handling for all event types
  // - Idempotency handling
  // - Error handling and retry logic
  // 150-250 lines
}});
```

### Webhook Sending (Outbound)
- **Webhook Registration API**: CRUD endpoints for webhook subscriptions
- **Event Queue**: Message queue implementation for reliable delivery
- **Retry Logic**: Exponential backoff retry implementation
- **Webhook Security**: HMAC signature generation code
- **Include complete webhook system (400-600 lines)**

## 8. RATE LIMITING & QUOTAS
- **Rate Limit Implementation**: Complete rate limiting middleware with Redis
- **Quota Tracking**: API usage tracking and billing code
- **Rate Limit Headers**: X-RateLimit-* header implementation
- **Quota Exceeded Handling**: 429 response handling examples
- **Include complete rate limiting system (200-300 lines)**

## 9. API VERSIONING IMPLEMENTATION
- **URL Versioning**: /v1, /v2 routing implementation
- **Header Versioning**: Accept-Version header handling
- **Deprecation Strategy**: Sunset header and migration guides
- **Version Migration**: Code examples for breaking changes
- **Include versioning system (150-250 lines)**

## 10. ERROR HANDLING & DEBUGGING
- **Error Response Format**: Standardized error response structure
- **Error Codes**: Complete list of application error codes
- **Debug Mode**: Request ID tracking and debug logging
- **API Health Check**: /health endpoint implementation
- **Include error handling utilities (200-300 lines)**

IMPORTANT: This should be a COMPLETE, PRODUCTION-READY API documentation that includes every single endpoint specification, complete SDK implementations in 3+ languages, full integration code for all third-party services, and everything a developer needs to integrate with the API."""
                
                # Format the template with actual values
                api_prompt = api_prompt.format(prompt=user_prompt, context=research_context, discussion=conversation_summary)

                api_doc = self.generate_response(api_prompt, research_context, temperature=0.3, max_tokens=doc_max_tokens)
                documents.append({
                    "title": "API Documentation & Integration Guide",
                    "filename": "04_api_documentation.md",
                    "content": api_doc.content,
                    "category": "api"
                })
                logger.info(f"Document 4 generated successfully ({len(api_doc.content)} chars)")
            except Exception as e:
                logger.error(f"Failed to generate API Documentation: {e}")
                documents.append({
                    "title": "API Documentation & Integration Guide",
                    "filename": "04_api_documentation.md",
                    "content": f"# API Documentation\n\n*Error generating document: {str(e)}*\n\nPlease retry or check the logs for details.",
                    "category": "api"
                })

        logger.info(f"Generated {len(documents)} specialized documents")
        return documents

    def generate_final_plan(self,
                          user_prompt: str,
                          research_context: str,
                          conversation_summary: str) -> LLMMessage:
        """Generate final development plan - now creates multiple documents"""
        
        # Check if we have enough content for multiple documents
        total_content_length = len(research_context) + len(conversation_summary)
        
        if total_content_length > 15000:  # Substantial content - create multiple documents
            logger.info("Generating multiple specialized documents due to comprehensive content")
            
            # Generate multiple documents
            documents = self.generate_multiple_documents(user_prompt, research_context, conversation_summary)
            
            # Create a summary document that references all the specialized documents
            summary_content = f"""# Complete Implementation Documentation Suite

Generated {len(documents)} comprehensive documents for: **{user_prompt}**

## Document Overview:

"""
            for i, doc in enumerate(documents, 1):
                summary_content += f"### {i}. {doc['title']} ({doc['filename']})\n"
                summary_content += f"**Category:** {doc['category'].title()}\n"
                summary_content += f"**Content Length:** {len(doc['content']):,} characters\n\n"

            summary_content += """## Implementation Workflow:

1. **Start with System Architecture** - Review the technical specifications and understand the overall system design
2. **Follow the Implementation Guide** - Use the step-by-step development plan and setup instructions  
3. **Implement Security & Testing** - Follow the security guidelines and set up comprehensive testing
4. **Use API Documentation** - Integrate with external services and implement API endpoints

Each document is designed to be comprehensive and actionable. Download each document for detailed implementation guidance.

## Next Steps:
1. Download all documents
2. Review the system architecture first
3. Set up your development environment using the implementation guide
4. Follow the phased development approach outlined in the documents

*These documents provide everything needed to build a production-ready application from start to finish.*"""

            # Store the documents for download (this will be handled by the file manager)
            return LLMMessage(
                llm_type=LLMType.DEEPSEEK,
                content=summary_content,
                confidence_score=0.9,
                metadata={"documents": documents, "multi_document": True}
            )
        
        else:
            # Fall back to single comprehensive document for smaller projects
            logger.info("Generating single comprehensive document due to limited content")
            
            prompt = f"""
            Create a COMPREHENSIVE, PRODUCTION-READY architectural design document and development plan for: {user_prompt}

            RESEARCH FINDINGS: {research_context}
            TECHNICAL DISCUSSION: {conversation_summary}

            Generate a complete planning and design document covering:
            - System architecture and design philosophy (diagrams and explanations, NOT code)
            - Technology stack with detailed justification and trade-offs
            - Implementation roadmap with phases and milestones
            - Component design and interaction patterns (conceptual, NOT implementations)
            - Security, testing, and deployment strategies
            - API design patterns and integration approaches (NOT actual API code)
            - Operations, monitoring, and maintenance planning

            IMPORTANT: Focus on WHAT to build and WHY. Include minimal code examples ONLY for critical concepts.
            This is planning documentation, not a code repository. Make it comprehensive enough for a team to understand 
            the architecture and plan development, but save detailed implementation for the development phase."""
            
            return self.generate_response(prompt, research_context, temperature=0.3, max_tokens=Config.DEEPSEEK_STAGE9_MAX_TOKENS)
    
    def validate_quality(self, content: str, criteria: List[str]) -> Dict[str, Any]:
        """Validate the quality of generated content against specific criteria"""
        
        criteria_text = "\n".join([f"- {criterion}" for criterion in criteria])
        
        prompt = f"""
        Please evaluate the following content against these quality criteria:

        CONTENT TO EVALUATE:
        {content}

        QUALITY CRITERIA:
        {criteria_text}

        For each criterion, provide:
        - A score from 0.0 to 1.0
        - Specific feedback on strengths and weaknesses
        - Suggestions for improvement

        Return your evaluation in a structured format.
        """
        
        response = self.generate_response(prompt)
        
        # Parse the response to extract quality scores
        # This is a simplified implementation - in practice you'd want more sophisticated parsing
        quality_scores = {}
        
        # Extract scores from response (this would be more sophisticated in production)
        lines = response.content.split('\n')
        for line in lines:
            if 'score' in line.lower() and ':' in line:
                parts = line.split(':')
                if len(parts) >= 2:
                    criterion = parts[0].strip().lower()
                    score_text = parts[1].strip()
                    try:
                        # Extract first number from the score text
                        import re
                        numbers = re.findall(r"[-+]?\d*\.\d+|\d+", score_text)
                        if numbers:
                            quality_scores[criterion] = float(numbers[0])
                    except (ValueError, IndexError):
                        continue
        
        return {
            'overall_score': sum(quality_scores.values()) / len(quality_scores) if quality_scores else 0.0,
            'criterion_scores': quality_scores,
            'feedback': response.content
        }
    
    def generate_research_plan(self, user_prompt: str) -> Dict[str, Any]:
        """Generate comprehensive research queries focused on complete implementation"""
        
        research_prompt = f"""You are a research expert. For the following project request: "{user_prompt}"

Generate 8-12 comprehensive search queries that would gather ALL information needed for complete implementation from start to finish. Focus on:

**CORE IMPLEMENTATION RESEARCH:**
1. Technology stack and framework recommendations with specific versions
2. System architecture patterns and design principles
3. Database design and data modeling best practices
4. API design patterns and implementation examples

**DETAILED IMPLEMENTATION GUIDANCE:**
5. Step-by-step implementation tutorials and code examples
6. Production deployment strategies and infrastructure setup
7. Security implementation and authentication patterns
8. Testing strategies and quality assurance approaches

**OPERATIONAL & MAINTENANCE RESEARCH:**
9. Performance optimization and monitoring solutions
10. Error handling and fault tolerance patterns
11. Scalability considerations and load balancing
12. DevOps practices and CI/CD pipeline setup

**PRACTICAL CONSIDERATIONS:**
13. Common pitfalls and troubleshooting guides
14. Resource requirements and timeline estimation
15. Team structure and development workflow
16. Documentation and maintenance strategies

Return your response as a JSON object with this structure:
{{
    "queries": [
        "specific technical implementation query 1",
        "specific deployment and setup query 2",
        "specific architecture pattern query 3",
        ...
    ],
    "research_focus": "comprehensive implementation and deployment guidance"
}}

Make each query specific, technical, and focused on actionable implementation details. Include queries for setup guides, code examples, production deployment, and operational procedures."""

        response = self.generate_response(research_prompt, max_tokens=Config.DEEPSEEK_STAGE4_MAX_TOKENS)
        
        try:
            # Try to parse JSON from the response
            import json
            import re
            
            content = response.content
            # Look for JSON object in the response
            json_match = re.search(r'\{.*\}', content, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                research_plan = json.loads(json_str)
                logger.info(f"Successfully parsed research plan with {len(research_plan.get('queries', []))} queries")
                return research_plan
            else:
                logger.warning("No JSON found in research plan response, using fallback")
                
        except Exception as e:
            logger.error(f"Failed to parse research plan JSON: {e}")
        
        # Fallback: extract queries from text
        lines = response.content.split('\n')
        queries = []
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#') and len(line) > 10:
                # Remove common prefixes and clean up
                line = re.sub(r'^[\d\.\-\*\+\>\s]*', '', line)
                line = line.strip('"\'')
                if line and len(line) > 10:
                    queries.append(line)
        
        return {
            "queries": queries[:8],  # Limit to 8 queries
            "research_focus": "Technical implementation and best practices"
        }
    
    def extract_research_insights(self, user_prompt: str, search_results: List) -> List[Dict[str, Any]]:
        """Extract key insights from search results using LLM analysis"""
        
        # Prepare search results summary
        results_summary = ""
        for i, result in enumerate(search_results[:10], 1):  # Limit to top 10 results
            title = getattr(result, 'title', 'Unknown')
            snippet = getattr(result, 'snippet', 'No description')
            results_summary += f"{i}. {title}\n   {snippet}\n\n"
        
        insight_prompt = f"""Analyze these search results for the request: "{user_prompt}"

SEARCH RESULTS:
{results_summary}

Extract 5-8 key insights that would be most valuable for understanding and implementing this request. Focus on:

1. Technical architecture patterns
2. Implementation strategies  
3. Tool and framework recommendations
4. Performance considerations
5. Common challenges and solutions
6. Best practices and patterns

Return insights as a JSON array:
[
    {{
        "insight": "specific technical insight",
        "source": "which search result(s) this came from",
        "relevance": "why this matters for the request"
    }},
    ...
]

Make insights actionable and technically specific."""

        response = self.generate_response(insight_prompt, max_tokens=Config.DEEPSEEK_STAGE4_MAX_TOKENS)
        
        try:
            # Try to parse JSON array from response
            import json
            import re
            
            content = response.content
            # Look for JSON array in the response
            json_match = re.search(r'\[.*\]', content, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                insights_data = json.loads(json_str)
                
                # Convert to the expected format
                insights = []
                for item in insights_data:
                    if isinstance(item, dict) and 'insight' in item:
                        insights.append({
                            'content': item['insight'],
                            'source': item.get('source', 'search results'),
                            'relevance_score': 0.8,
                            'type': 'technical_insight'
                        })
                
                logger.info(f"Successfully extracted {len(insights)} insights from search results")
                return insights
                
        except Exception as e:
            logger.error(f"Failed to parse insights JSON: {e}")
        
        # Fallback: extract insights from text
        lines = response.content.split('\n')
        insights = []
        current_insight = ""
        
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#'):
                # Remove list prefixes and clean up
                line = re.sub(r'^[\d\.\-\*\+\>\s]*', '', line)
                line = line.strip('"\'')
                
                if len(line) > 20:  # Reasonable insight length
                    insights.append({
                        'content': line,
                        'source': 'research analysis',
                        'relevance_score': 0.7,
                        'type': 'extracted_insight'
                    })
        
        return insights[:8]  # Limit to 8 insights